/*
  Copyright (C) 2011 - 2019 by the authors of the ASPECT code.

  This file is part of ASPECT.

  ASPECT is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2, or (at your option)
  any later version.

  ASPECT is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with ASPECT; see the file LICENSE.  If not see
  <http://www.gnu.org/licenses/>.
*/



#include <aspect/mesh_refinement/isolines.h>
#include <aspect/utilities.h>
#include <aspect/geometry_model/interface.h>

#include <deal.II/base/quadrature_lib.h>
#include <deal.II/fe/fe_values.h>
#include <math.h>

namespace aspect
{
  namespace MeshRefinement
  {
    template <int dim>
    void
    Isolines<dim>::update ()
    {
      const double time = this->get_time() /
                          (this->convert_output_to_years()
                           ?
                           year_in_seconds
                           :
                           1.0);

      max_refinement_level.set_time(time);
    }

    template <int dim>
    void
    Isolines<dim>::tag_additional_cells () const
    {

      /**
       * TODO: This is the main function which requires work. It uses a list
       * of parameters which needs to be loaded (generated by the parse function
       * and it doesn't change).
       * 1. Load required parameters
       * 2. per cell:
       * 2.1. use map to determaine the four flag cells based on whether the values are between the isolines
       * 2.2. Use the flags to set either tag a cell for coarsening or refinement
       */
      for (const auto &cell : this->get_triangulation().active_cell_iterators())
        {
          if (cell->is_locally_owned())
            {
              bool coarsen = false;
              bool clear_refine = false;
              bool refine = false;
              bool clear_coarsen = false;

              for ( unsigned int v = 0; v < GeometryInfo<dim>::vertices_per_cell;  ++v)
                {
                  const Point<dim> vertex = cell->vertex(v);
                  Utilities::NaturalCoordinate<dim> point =
                    this->get_geometry_model().cartesian_to_other_coordinates(vertex, coordinate_system);

                  const double maximum_refinement_level = max_refinement_level.value(Utilities::convert_array_to_point<dim>(point.get_coordinates()));

                  if (cell->level() >= rint(maximum_refinement_level))
                    clear_refine = true;
                  if (cell->level() >  rint(maximum_refinement_level))
                    {
                      coarsen = true;
                      break;
                    }
                }

              if (clear_refine)
                cell->clear_refine_flag ();
              if (coarsen)
                cell->set_coarsen_flag ();
            }
        }
    }

    template <int dim>
    void
    Isolines<dim>::
    declare_parameters (ParameterHandler &prm)
    {
      prm.enter_subsection("Mesh refinement");
      {

        prm.enter_subsection("Isolines");
        {
          /**
           * TODO
           */
          prm.declare_entry ("isolines", "depth",
                             Patterns::Anything(),
                             "Todo");

        }
        prm.leave_subsection();
      }
      prm.leave_subsection();
    }

    template <int dim>
    void
    Isolines<dim>::parse_parameters (ParameterHandler &prm)
    {
      /**
       * Todo:
       * 1. make enum
       * 2. make container variable in header file
       * 3. read in variables into struct
       */

      // fill parameter list_of_composition_names: Todo: These should be enums
      std::vector<std::string> list_of_composition_names = {"Temperature", "Density", "viscosity", "strain-rate", "Pressure"};
      const std::vector<std::string> compositions = this->introspection().get_composition_names();
      list_of_composition_names.insert(list_of_composition_names.end(), compositions.begin(), compositions.end());

      // parameter has_background_field, what does it do, what do we want?

      prm.enter_subsection("Mesh refinement");
      {
        prm.enter_subsection("Isolines");
        {
          isolines = Utilities::parse_map_to_double_array (prm.get("Isolines"), // input_string
                                                           list_of_composition_names, // list_of_keys
                                                           has_background_field, // expects_background_field
                                                           "Isoterms", // property_name
                                                           true, // allow_multiple_values_per_key
                                                           2, // n_values_per_key: check is 2 is correct (min, max)
                                                           true); // allow missing keys: check whether we want true or false
          /**
           * In the end I would like to have the following structure:
           * a vector containing std::vector<std::map<std::string,std::pair<double,double> > >
           * Where the std::string should become a enum.
           */

        }
        prm.leave_subsection();
      }
      prm.leave_subsection();
    }
  }
}

// explicit instantiations
namespace aspect
{
  namespace MeshRefinement
  {
    ASPECT_REGISTER_MESH_REFINEMENT_CRITERION(Isolines,
                                              "isolines",
                                              "Todo")
  }
}
